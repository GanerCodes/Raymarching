import java.lang.RuntimeException
import json

FPS = 75
timeScale = 1
upscale = 1

screenshotUpscale = 3
screenshotRes = (3840, 2160)

vp_loc = PVector(0, 0.5, 0)
vp_ang = PVector(0, 0)

shaderReloadTime = 0
canMoveCameraAngle = True
shade = None
keys = {}

tmp_shader_name = "SHADER_COMPILED.glsl"

def rot_XZ(p, r):
    return PVector(p.x*cos(r)-p.z*sin(r), p.y, p.x*sin(r)+p.z*cos(r))
def rot_YZ(p, r):
    return PVector(p.x, p.y*cos(r)-p.z*sin(r), p.y*sin(r)+p.z*cos(r))

def hasKey(key):
    global keys
    return key in keys and keys[key]

def create_main_shader(file_name=tmp_shader_name, shader_list_file="file_list.txt", shader_file_prefix="./data/"):
    file_name = shader_file_prefix + file_name
    
    with open(shader_list_file) as f:
        shader_list = map(lambda x: shader_file_prefix + x.strip(), filter(None, f.readlines()))
    
    with open(file_name, 'w') as f:
        f.write("// This is an AUTOGENERATED file, do not edit!\n\n\n\n")
        for shade_name in shader_list:
            f.write("////////// {} //////////\n\n".format(shade_name))
            with open(shade_name, 'r') as f2:
                f.write(f2.read() + '\n\n')

def getLoc(ms):
    t = (ms / 1000.0) % 1.0
    s = int(ms / 1000)
    
    s1 = s % len(info['coords'])
    s2 = (s + 1) % len(info['coords'])
    
    a = PVector(*info['coords'][s1])
    b = PVector(*info['coords'][s2])
    c = a.lerp(b, t)
    
    return t, s, s1, s2, a, b, c

def sendPara(shade):
    shade.set("u_resolution", float(width), float(height))
    shade.set("u_time", 0.001 * timeScale * millis())
    shade.set("vp_ang", vp_ang.x, vp_ang.y)
    shade.set("vp_loc", vp_loc.x, vp_loc.y, vp_loc.z)
    
    t, s, s1, s2, a, b, c = getLoc(millis())
    shade.set("vp_loc",
        info['size'] / 2 - c.x - 0.5,
        0.25,
        c.y - info['size'] / 2 + 0.5
    )
    c2 = getLoc(millis() + 500)[-1]
    shade.set("vp_ang", atan2(c.x - c2.x, c.y - c2.y), vp_ang.y)

def settings():
    noSmooth()

def setup():
    global buffer, upscale, mouse_pos, loaded_img, info
    # fullScreen(P2D)
    size(1500, 900, P2D)
    
    with open("./data/path.txt", 'r') as f:
        info = json.loads(f.read())
        print(info)
        loaded_img = createGraphics(info['size'], info['size'])
        loaded_img.noSmooth()
        loaded_img.beginDraw()
        loaded_img.background(0)
        for i, row in enumerate(info['grid']):
            for o, v in enumerate(row):
                loaded_img.set(i, o, color(v))
        loaded_img.endDraw()
        loaded_img.save("test_image.png")
    
    mouse_pos = PVector(width / 2, height / 2)
    frameRate(FPS)
    buffer = createGraphics(int(width * upscale), int(height * upscale), P2D)

def draw():
    global shade, vp_loc, vp_ang, shaderReloadTime
    
    if millis() >= shaderReloadTime:
        shaderReloadTime = millis() + 1000
        try:
            create_main_shader()
            shade_temp = loadShader(tmp_shader_name)
            shade_temp.create()
            shade_temp.compile()
            if len(shade_temp.fragmentShaderSource) <= 12:
                raise java.lang.RuntimeException("Shader too short to compile.")
            shade = loadShader(tmp_shader_name)
            shade.set("u_resolution", float(width), float(height))
            shade.set("image", loaded_img)
            shade.set("count", info['size'])
        except java.lang.RuntimeException as err:
            print("Error compiling shader! {}".format(err))
            return
        
        print("Sucessfully compiled shader!")
    
    if not shade:
        return
    
    if canMoveCameraAngle:
        mouse_pos.add(PVector(mouseX - pmouseX, mouseY - pmouseY))
        
        mouse_pos.y = constrain(mouse_pos.y, 0, height)
        
        vp_ang = PVector(
            map(mouse_pos.x, 0, width , -PI, PI),
            map(mouse_pos.y, 0, height, -PI / 2.0, PI / 2.0)
        )
    
    sendPara(shade)
    
    buffer.filter(shade)
    
    image(buffer, 0, 0, width, height)
    fill(255, 0, 0)
    text(frameRate, 0, 10)
    
    moveVec = PVector(0, 0, 0)
    if hasKey(87):
        moveVec.add(PVector( 0,  0, -1))
    if hasKey(83):
        moveVec.add(PVector( 0,  0,  1))
    if hasKey(65):
        moveVec.add(PVector(-1,  0,  0))
    if hasKey(68):
        moveVec.add(PVector( 1,  0,  0))
    
    moveVec = rot_XZ(rot_YZ(moveVec, -vp_ang.y), vp_ang.x)
    
    if hasKey(32):
        moveVec.add(PVector( 0,  1,  0))
    if hasKey(16):
        moveVec.add(PVector( 0, -1,  0))
    
    vp_loc.add(moveVec.setMag((25.0 if hasKey(17) else 5.0) / frameRate))
    
def keyPressed():
    global keys, canMoveCameraAngle
    keys[keyCode] = True
    if hasKey(82):
        canMoveCameraAngle = not canMoveCameraAngle

def keyReleased():
    global keys
    if hasKey(80):
        newBuf = createGraphics(
            screenshotUpscale * screenshotRes[0],
            screenshotUpscale * screenshotRes[0],
            P2D
        )
        newBuf.beginDraw()
        newBuf.endDraw()
        sendPara(shade)
        newBuf.filter(shade)
        
        finalBuf = createGraphics(screenshotRes[0], screenshotRes[1], P2D)
        finalBuf.beginDraw()
        finalBuf.image(newBuf, 0, 0, screenshotRes[0], screenshotRes[1])
        finalBuf.save("screenshot.png")
        finalBuf.endDraw()
        print("Screenshot saved!")
        
    keys[keyCode] = False

def mouseClicked():
    global canMoveCameraAngle
    if mouseButton == CENTER:
        canMoveCameraAngle = not canMoveCameraAngle